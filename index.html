<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARS - Baby Hippo Life Simulation</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            font-family: 'Comic Sans MS', cursive;
            background: linear-gradient(135deg, #87CEEB, #98FB98);
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #left-sidebar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 390px;
            background: rgba(0,0,0,0.7);
            z-index: 100;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            transition: transform 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }

        #left-sidebar.collapsed {
            transform: translateX(-100%) translateX(40px);
        }

        #messageLog {
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 10px;
            margin-top: 10px;
            flex-grow: 1; /* Allow this to grow */
            min-height: 100px; /* Minimum height */
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .log-message {
            font-size: 12px;
            margin: 2px 0;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
        }

        #toggle-log-btn {
            position: absolute;
            top: 0;
            right: -30px;
            width: 30px;
            height: 30px;
            padding: 0;
            line-height: 30px;
            text-align: center;
            background: rgba(0,0,0,0.7);
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
            border-left: 1px solid #666;
        }

        #ui.collapsed #toggle-log-btn {
            right: -40px;
        }
        
        #statsPanel {
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            min-width: 200px;
        }
        
        .stat-bar {
            margin: 5px 0;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .stat-fill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }
        
        .hunger { background: linear-gradient(90deg, #ff6b6b, #ff3838); }
        .thirst { background: linear-gradient(90deg, #4ecdc4, #26a69a); }
        .bladder { background: linear-gradient(90deg, #ffe66d, #ffcc02); }
        .bowel { background: linear-gradient(90deg, #8b4513, #5d2f0a); }
        .happiness { background: linear-gradient(90deg, #ff9ff3, #ff6ec7); }
        
        .stat-label {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            font-weight: bold;
        }
        
        #controls {
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 10px;
        }
        
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
        }
        
        #journalBtn { background: #607D8B; }
        #journalBtn:hover { background: #546E7A; }

        /* Journal Styles */
        #journal { 
            position: absolute;
            top: 0;
            right: -100%; /* Start off-screen */
            width: 400px;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 400;
            color: white;
            padding: 20px;
            box-shadow: -5px 0 15px rgba(0,0,0,0.5);
            transition: right 0.5s ease-in-out;
            display: flex;
            flex-direction: column;
        }
        
        #story {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 600px;
            border: 3px solid #FFD700;
        }
        
        #curtains {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 300;
            pointer-events: none;
        }
        
        .curtain {
            position: absolute;
            top: 0;
            height: 100%;
            width: 50%;
            background: linear-gradient(90deg, #8B0000, #DC143C);
            transition: transform 3s ease-in-out;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
        }
        
        .curtain-left {
            left: 0;
            transform: translateX(0);
        }
        
        .curtain-right {
            right: 0;
            transform: translateX(0);
        }
        
        .curtains-open .curtain-left {
            transform: translateX(-100%);
        }
        
        .curtains-open .curtain-right {
            transform: translateX(100%);
        }
        

        #actionQueue {
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 10px;
            margin-top: 10px;
            /* Removed absolute positioning */
        }

        #actionQueue h4 {
            margin-top: 0; /* Remove extra space above title */
            margin-bottom: 8px;
        }

        .action-item {
            margin: 5px 0;
            padding: 5px 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .action-current {
            background: rgba(255, 215, 0, 0.8);
            color: black;
            font-weight: bold;
            transform: scale(1.05);
        }

        .action-queued {
            background: rgba(255, 255, 255, 0.1);
        }

        .action-urgent {
            background: rgba(255, 0, 0, 0.6);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .action-icon {
            margin-right: 8px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="left-sidebar">
            <button id="toggle-log-btn">◀</button>
            <div id="statsPanel">
                <h3>MARS Status</h3>
                <div>
                    <div class="stat-bar">
                        <div class="stat-fill hunger" id="hungerBar"></div>
                        <div class="stat-label">Hunger</div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-fill thirst" id="thirstBar"></div>
                        <div class="stat-label">Thirst</div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-fill bladder" id="bladderBar"></div>
                        <div class="stat-label">Bladder</div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-fill bowel" id="bowelBar"></div>
                        <div class="stat-label">Bowel</div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-fill happiness" id="happinessBar"></div>
                        <div class="stat-label">Happiness</div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-fill" id="energyBar" style="background: linear-gradient(90deg, #ffd166, #fcbf49);"></div>
                        <div class="stat-label">Energy</div>
                    </div>
                </div>
                <div>Age: <span id="ageDisplay">0 days</span></div>
                <div>Size: <span id="sizeDisplay">Baby</span></div>
                <div>Day/Time: <span id="dayTimeDisplay">Day 1, 08:00</span></div>
                <div>Score: <span id="scoreDisplay">0</span></div>
            </div>
            
            <div id="controls">
                <button id="timeSpeed">Time: 1x</button>
                <button id="sleepBtn">Sleep</button>
                <button id="journalBtn">Journal</button>
                <button onclick="saveGame()">Save Game</button>
                <button onclick="loadGame()">Load Game</button>
                <button id="splashBtn" disabled>Splash</button>
            </div>

            <div id="actionQueue">
                <h4>🧠 MARS's Mind</h4>
                <div id="actionList">
                    <div class="action-item action-current">
                        <span class="action-icon">🎯</span>
                        <span>Thinking...</span>
                    </div>
                </div>
                <div style="margin-top: 10px; font-size: 11px; opacity: 0.8;">
                    <div>🤖 Autonomous Mode: ON</div>
                    <div id="aiStatus">Evaluating needs...</div>
                </div>
            </div>

            <div id="messageLog">
                <!-- Messages will be added here -->
            </div>
        </div>
        
        
        <div id="curtains">
            <div class="curtain curtain-left"></div>
            <div class="curtain curtain-right"></div>
        </div>
        
        <div id="story" style="display: none;">
            <h2>🦛 MARS Baby Hippo Simulator 🦛</h2>
            <p id="storyText"></p>
        </div>

        <!-- Story Log Modal -->
        <!-- Journal Popup -->
        <div id="journal">
            <div class="journal-header">
                <h2>MARS's Journal</h2>
                <button id="closeJournalBtn">Close</button>
            </div>
            <div class="journal-tabs">
                <div class="journal-tab active" data-tab="story">Story</div>
                <div class="journal-tab" data-tab="missions">Missions</div>
                <div class="journal-tab" data-tab="quests">Quests</div>
                <div class="journal-tab" data-tab="logs">Logs</div>
                <div class="journal-tab" data-tab="status">Status</div>
                <div class="journal-tab" data-tab="character">Character</div>
            </div>
            <div class="journal-content">
                <div class="journal-pane active" id="journal-story">
                    <h3>The Story of MARS</h3>
                    <p>The full story of MARS the baby hippo will be written here.</p>
                </div>
                <div class="journal-pane" id="journal-missions">
                    <h3>Current Missions</h3>
                    <p>Mission objectives will be listed here.</p>
                </div>
                <div class="journal-pane" id="journal-quests">
                    <h3>Active Quests</h3>
                    <p>Side quests and special tasks will appear here.</p>
                </div>
                <div class="journal-pane" id="journal-logs">
                    <h3>Event Logs</h3>
                    <ul id="storyLogList" style="list-style: none; padding-left: 0; margin: 0;"></ul>
                </div>
                <div class="journal-pane" id="journal-status">
                    <h3>Hippo Status</h3>
                    <p>Detailed character status and buffs/debuffs.</p>
                </div>
                <div class="journal-pane" id="journal-character">
                    <h3>Character Sheet</h3>
                    <p>Information about MARS's personality, growth, and history.</p>
                </div>
            </div>
            <div class="journal-footer">
                <p>A tribute to the $MARS coin project.</p>
            </div>
        </div>

        <!-- (The old storyLogModal is now integrated into the journal) -->
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        let scene, camera, renderer, mars, gameWorld;
        let ambientLight, sunLight;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isGameStarted = false;
        let storyStep = 0;
        let timeMultiplier = 1;
        let lastTime = Date.now();
        // Time of day (0-24 hours). Start morning at 8:00
        let gameTime = 8;
        const DAY_LENGTH_SECONDS_1X = 720; // 12 minutes real-time per in-game day at 1x
        let inDream = false;
        let sleepStartHour = null; // hour when sleep action started
        let storyLog = [];
        let isBackflipping = false;
        let backflipState = null;
        // Habitat boundaries (fence posts at ~19, ground radius 20)
        const HABITAT_RADIUS = 19;
        const HABITAT_INNER_RADIUS = 18.5; // soft margin to avoid clipping fence
        // Track a progressive poop pile
        let lastPoopPile = { center: null, meshes: [] };
        // Periodic beetle swarm behavior
        let lastPoopSwarmTime = 0;
        const POOP_SWARM_INTERVAL_MS = 10000; // about once every 10 seconds
        
        // Game Objects
        let rocks = [];
        let beetles = [];
        let pools = [];
        let poopSpots = [];
        let frogs = [];
        let currentTarget = null;
        let pathfinding = null;
        let splashParticles = null;
        // Frog spawning system
        let frogSpawner = {
            lastSpawn: 0,
            spawnInterval: 9000, // ~9 seconds between spawn attempts
            maxFrogs: 4,
            spawnChance: 0.6
        };
        
        // Beetle spawning system
        let beetleSpawner = {
            lastSpawn: 0,
            spawnInterval: 8000, // 8 seconds between spawns
            maxBeetles: 15, // Maximum beetles in world
            spawnChance: 0.7 // 70% chance to spawn when interval passed
        };
        
        // MARS AI System
        let marsAI = {
            currentAction: 'idle',
            actionQueue: ['explore', 'rest', 'drink', 'hunt', 'splash'],
            queueIndex: 0,
            actionStartTime: 0,
            isExecutingUrgentAction: false,
            lastThoughtTime: 0,
            thoughtInterval: 3000, // Think every 3 seconds
            actionHistory: []
        };
        
        // Action definitions
        const ACTIONS = {
            idle: { icon: '😴', name: 'Resting', duration: 5000 },
            explore: { icon: '🚶', name: 'Exploring', duration: 8000 },
            hunt: { icon: '🪲', name: 'Hunting bugs', duration: 10000 },
            hunting_beetle: { icon: '🏃‍♂️', name: 'Chasing beetle!', duration: 3000 },
            drink: { icon: '💧', name: 'Drinking water', duration: 4000 },
            poop: { icon: '💩', name: 'Relieving bowel', duration: 3000 },
            pee: { icon: '💛', name: 'Relieving bladder', duration: 2000 },
            eat: { icon: '🍃', name: 'Eating grass', duration: 6000 },
            sleep: { icon: '🛌', name: 'Sleeping', duration: 8000 },
            splash: { icon: '💦', name: 'Splashing', duration: 4000 }
        };
        
        // MARS Stats
        let marsStats = {
            hunger: 0,
            thirst: 0,
            bladder: 0,
            bowel: 0,
            happiness: 75,
            age: 0, // in days
            size: 'baby',
            energy: 100,
            score: 0
        };
        // Eating cooldown to prevent rapid beetle consumption
        let lastBeetleEaten = 0;
        const BEETLE_EATING_COOLDOWN = 500; // 0.5 seconds between beetle eating
        
        // Story sequence
        const storySequence = [
            "On June 26, 2025, at Tanganyika Wildlife Park in Kansas, a miracle happened...",
            "Baby MARS was born to hippopotamus pair Posie and Pluto! 🎉",
            "As a rare pygmy hippo, MARS represents hope for conservation efforts worldwide.",
            "But MARS became famous for something adorable... refusing to leave the pool until mom gave her 'the look'! 👀",
            "Now it's time to help MARS grow up healthy and happy in her habitat!",
            "Welcome to MARS's world! Let's begin her life simulation adventure! 🌟"
        ];

        // Dream sequences for story progression (Phase 2)
        const DREAM_SEQUENCES = [
            {
                ageTriggerDays: 1,
                dialogue: [
                    "I was just a tiny hippo who loved the water...",
                    "Mom gave me THAT look when I wouldn't get out...",
                    "Suddenly, millions of people knew my name!",
                    "I became famous for being stubborn... just like a real hippo!"
                ]
            },
            {
                ageTriggerDays: 2,
                dialogue: [
                    "Dad taught me how real hippos live in the wild...",
                    "Rivers in Liberia where my ancestors swam freely...",
                    "I'm not just cute - I'm part of something bigger!",
                    "Every day I grow stronger, wilder, prouder..."
                ]
            },
            {
                ageTriggerDays: 3,
                dialogue: [
                    "Scientists came to study me, to learn about my kind...",
                    "Only 2,500 of us left in all the world...",
                    "But I'm helping people care, helping them understand...",
                    "My story gives hope to hippos everywhere!"
                ]
            },
            {
                ageTriggerDays: 4,
                dialogue: [
                    "Children visit from schools around the world...",
                    "They learn that every creature matters...",
                    "My fame helps protect my wild cousins...",
                    "I may be small, but my impact is mighty!"
                ]
            }
        ];

        // Story manager
        let storyManager = {
            currentDay: 1,
            completedDreams: [], // contains indices of completed dreams
            lastDreamDay: 0 // last day number a dream was shown
        };
        
        // Initialize the game
        function init() {
            // Setup Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Camera setup (overhead view)
            const aspect = window.innerWidth / window.innerHeight;
            const d = 25;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.zoom = 2; // 2x zoom
            camera.updateProjectionMatrix();
            camera.position.set(30, 30, 30);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 50, 50);
            sunLight.castShadow = true;
            sunLight.shadow.camera.near = 0.1;
            sunLight.shadow.camera.far = 200;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
            
            createWorld();
            createMars();
            setupEventListeners();
            
            // Start opening sequence immediately
            setTimeout(startOpeningSequence, 500);

            // Add instructions to the message log
            showMessage("• Right Click: Interact with rocks");
            showMessage("• Left Click: Override and move MARS");
            showMessage("Manual Controls:");
            showMessage(" "); // Spacer
            showMessage("• Right-click rocks to help him hunt");
            showMessage("• You can still guide him with clicks");
            showMessage("• He prioritizes urgent needs (>50%)");
            showMessage("• Watch his action queue up above");
            showMessage("• MARS thinks and acts independently");
            showMessage("🤖 MARS is Autonomous!");
        }
        
        function createWorld() {
            // Ground (circular farm area)
            const groundGeometry = new THREE.CircleGeometry(20, 32);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x228B22,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.userData = { type: 'ground' };
            scene.add(ground);
            
            // Fence around the area
            createFence();
            
            // Water pools
            createPools();
            
            // Rocks scattered around
            createRocks();
            
            // Central log
            createLog();
            
            // Grass patches
            createGrass();
        }
        
        function createFence() {
            const fenceGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2);
            const fenceMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                const fence = new THREE.Mesh(fenceGeometry, fenceMaterial);
                fence.position.x = Math.cos(angle) * 19;
                fence.position.z = Math.sin(angle) * 19;
                fence.position.y = 1;
                fence.castShadow = true;
                scene.add(fence);
            }
        }

        // Frogs: spawn from water, hop around within fence until eaten, max 4 on screen
        function manageFrogSpawning(currentTime) {
            const adjustedInterval = frogSpawner.spawnInterval / timeMultiplier;
            if (currentTime - frogSpawner.lastSpawn > adjustedInterval) {
                frogSpawner.lastSpawn = currentTime;
                if (frogs.length < frogSpawner.maxFrogs && Math.random() < frogSpawner.spawnChance) {
                    spawnFrog();
                } else if (frogs.length >= frogSpawner.maxFrogs) {
                    // At cap: choose a frog far from MARS to go hide under a rock/poop
                    let farFrog = null;
                    let bestD2 = -1;
                    for (const f of frogs) {
                        const dx = f.position.x - mars.position.x;
                        const dz = f.position.z - mars.position.z;
                        const d2 = dx*dx + dz*dz;
                        if (d2 > bestD2) { bestD2 = d2; farFrog = f; }
                    }
                    if (farFrog) {
                        const ud = farFrog.userData;
                        if (!ud.hideTarget) ud.hideTarget = pickHideTargetNear(farFrog.position);
                        if (ud.hideTarget) {
                            ud.state = 'hide';
                            // give it a push toward hiding
                            const dir = ud.hideTarget.clone().sub(farFrog.position).normalize();
                            ud.velocity.add(dir.multiplyScalar(0.3));
                        }
                    }
                }
            }
        }

        function spawnFrog() {
            if (pools.length === 0) return;
            const pool = pools[Math.floor(Math.random() * pools.length)];
            const geom = new THREE.SphereGeometry(0.35, 12, 12);
            const mat = new THREE.MeshLambertMaterial({ color: 0x2ecc71 });
            const frog = new THREE.Mesh(geom, mat);
            // Spawn near pool edge
            const ang = Math.random() * Math.PI * 2;
            const r = 3.8; // near pool radius 4
            frog.position.set(pool.position.x + Math.cos(ang) * r, 0.1, pool.position.z + Math.sin(ang) * r);
            frog.castShadow = true;
            frog.userData = {
                type: 'frog',
                spawnTime: Date.now(),
                vy: 0,
                velocity: new THREE.Vector3((Math.random()-0.5)*0.15, 0, (Math.random()-0.5)*0.15),
                hopTimer: 0,
                hopInterval: 0.6 + Math.random() * 0.8,
                hideTarget: pickHideTargetNear(pool.position),
                state: 'explore' // or 'hide'
            };
            frogs.push(frog);
            scene.add(frog);
        }

        function updateFrogs(deltaTime) {
            const currentTime = Date.now();
            manageFrogSpawning(currentTime);
            
            const gravity = 9.8;
            frogs.forEach((frog, index) => {
                const ud = frog.userData;
                // Choose behavior: if hideTarget exists (spawned from water), occasionally head to hide
                if (ud.state === 'explore' && ud.hideTarget && Math.random() < 0.005 * timeMultiplier) {
                    ud.state = 'hide';
                }

                if (ud.state === 'hide' && ud.hideTarget) {
                    const dir = ud.hideTarget.clone().sub(frog.position);
                    dir.y = 0;
                    if (dir.length() > 0.1) {
                        dir.normalize();
                        ud.velocity.lerp(dir.multiplyScalar(0.6), 0.2 * timeMultiplier);
                    } else {
                        // Arrived, switch back to explore after a pause
                        if (!ud.hideUntil) ud.hideUntil = currentTime + 1500;
                        if (currentTime > ud.hideUntil) {
                            ud.hideUntil = null;
                            ud.state = 'explore';
                        }
                    }
                } else {
                    // Randomly adjust walking direction
                    if (Math.random() < 0.03 * timeMultiplier) {
                        ud.velocity.add(new THREE.Vector3((Math.random()-0.5)*0.1, 0, (Math.random()-0.5)*0.1));
                    }
                }

                // Hopping: periodic upward impulse
                ud.hopTimer += deltaTime * timeMultiplier;
                if (ud.hopTimer > ud.hopInterval) {
                    ud.hopTimer = 0;
                    ud.hopInterval = 0.6 + Math.random() * 0.8;
                    ud.vy = 3.2 + Math.random() * 0.8;
                }

                // Apply movement and gravity
                ud.vy -= gravity * deltaTime;
                frog.position.y = Math.max(0.1, frog.position.y + ud.vy * deltaTime);
                if (frog.position.y <= 0.11 && ud.vy < 0) {
                    ud.vy = 0; // landed
                }
                // Horizontal move
                frog.position.add(ud.velocity.clone().multiplyScalar(0.6 * deltaTime));

                // Keep inside habitat; apply inward pull if beyond outer radius
                const dx = frog.position.x, dz = frog.position.z;
                const r = Math.sqrt(dx*dx + dz*dz);
                if (r > HABITAT_RADIUS) {
                    const inward = new THREE.Vector3(-dx, 0, -dz).normalize();
                    ud.velocity.add(inward.multiplyScalar(0.25));
                }
                if (r > HABITAT_INNER_RADIUS) {
                    const ang = Math.atan2(dz, dx);
                    frog.position.x = Math.cos(ang) * HABITAT_INNER_RADIUS;
                    frog.position.z = Math.sin(ang) * HABITAT_INNER_RADIUS;
                    const inward = new THREE.Vector3(-Math.cos(ang), 0, -Math.sin(ang));
                    ud.velocity.add(inward.multiplyScalar(0.2));
                }

                // MARS eats frog if close enough
                const dToMars = mars.position.distanceTo(frog.position);
                if (dToMars < 1.2) {
                    scene.remove(frog);
                    frogs.splice(index, 1);
                    feedMarsFrog();
                    showMessage("MARS ate a tasty frog! 🐸", Math.max(500, 1500 / timeMultiplier));
                    return;
                }

                // Face movement direction lightly
                const dir2d = ud.velocity.clone();
                if (dir2d.lengthSq() > 1e-4) {
                    const face = frog.position.clone().add(dir2d);
                    frog.lookAt(face.x, frog.position.y, face.z);
                }
            });
        }
        
        function createPools() {
            // Main pool
            const poolGeometry = new THREE.CircleGeometry(4, 16);
            const waterMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x006994,
                transparent: true,
                opacity: 0.7
            });
            
            const pool1 = new THREE.Mesh(poolGeometry, waterMaterial);
            pool1.position.set(-8, 0.1, -8);
            pool1.rotation.x = -Math.PI / 2;
            pool1.userData = { type: 'water' };
            scene.add(pool1);
            pools.push(pool1);
            
            const pool2 = new THREE.Mesh(poolGeometry, waterMaterial);
            pool2.position.set(8, 0.1, 8);
            pool2.rotation.x = -Math.PI / 2;
            pool2.userData = { type: 'water' };
            scene.add(pool2);
            pools.push(pool2);
            
            // Animate water
            animateWater();
        }
        
        function animateWater() {
            pools.forEach(pool => {
                // Apply time multiplier to water animation speed
                pool.material.opacity = 0.6 + Math.sin(Date.now() * 0.002 * timeMultiplier) * 0.1;
            });
            requestAnimationFrame(animateWater);
        }
        
        function createRocks() {
            const rockGeometry = new THREE.BoxGeometry(1, 0.5, 1);
            const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
            
            const rockPositions = [
                [5, 0.25, 3], [-3, 0.25, 7], [2, 0.25, -5],
                [-7, 0.25, 2], [6, 0.25, -8], [-2, 0.25, -3],
                [4, 0.25, 9], [-8, 0.25, -1]
            ];
            
            rockPositions.forEach(pos => {
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(pos[0], pos[1], pos[2]);
                rock.castShadow = true;
                rock.userData = { 
                    type: 'rock', 
                    hasBeenTurned: false,
                    lastRegenTime: Date.now(),
                    regenInterval: 20000, // 20 seconds to regenerate
                    isRegenerating: false,
                    regenBeetles: [] // Beetles swarming around this rock
                };
                rocks.push(rock);
                scene.add(rock);
            });
        }
        
        function createLog() {
            const logGeometry = new THREE.CylinderGeometry(0.5, 0.5, 4);
            const logMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const log = new THREE.Mesh(logGeometry, logMaterial);
            log.position.set(0, 0.5, 0);
            log.castShadow = true;
            log.userData = { type: 'log' };
            scene.add(log);
        }
        
        function createGrass() {
            const grassGeometry = new THREE.ConeGeometry(0.1, 0.5, 3);
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
            
            for (let i = 0; i < 50; i++) {
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 15;
                grass.position.x = Math.cos(angle) * radius;
                grass.position.z = Math.sin(angle) * radius;
                grass.position.y = 0.25;
                grass.scale.set(
                    0.5 + Math.random() * 0.5,
                    0.5 + Math.random() * 0.5,
                    0.5 + Math.random() * 0.5
                );
                scene.add(grass);
            }
        }
        
        function createSplashParticles() {
            const particleCount = 100;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = mars.position.x;
                positions[i * 3 + 1] = mars.position.y;
                positions[i * 3 + 2] = mars.position.z;
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.userData.velocities = [];

            const particleMaterial = new THREE.PointsMaterial({
                color: 0x4ecdc4,
                size: 0.3,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            splashParticles = new THREE.Points(particles, particleMaterial);
            splashParticles.visible = false;
            scene.add(splashParticles);
        }

        function animateSplash() {
            if (!splashParticles || !splashParticles.visible) return;

            const positions = splashParticles.geometry.attributes.position.array;
            const velocities = splashParticles.geometry.userData.velocities;
            let activeParticles = 0;

            for (let i = 0; i < positions.length / 3; i++) {
                if (velocities[i].y > -9) { // If particle is still "alive"
                    positions[i * 3] += velocities[i].x * 0.05;
                    positions[i * 3 + 1] += velocities[i].y * 0.05;
                    positions[i * 3 + 2] += velocities[i].z * 0.05;
                    velocities[i].y -= 0.5; // Gravity
                    activeParticles++;
                }
            }

            if (activeParticles === 0) {
                splashParticles.visible = false; // Hide when all particles are done
            }

            splashParticles.geometry.attributes.position.needsUpdate = true;
        }

        function triggerSplashEffect() {
            if (!splashParticles) createSplashParticles();

            const positions = splashParticles.geometry.attributes.position.array;
            const velocities = [];
            const splashPower = 3;

            for (let i = 0; i < positions.length / 3; i++) {
                positions[i * 3] = mars.position.x;
                positions[i * 3 + 1] = 0.1; // Start at water level
                positions[i * 3 + 2] = mars.position.z;

                const angle = Math.random() * Math.PI * 2;
                const horizontalSpeed = Math.random() * splashPower;
                velocities[i] = new THREE.Vector3(
                    Math.cos(angle) * horizontalSpeed,
                    Math.random() * 5 + 4, // Upward velocity
                    Math.sin(angle) * horizontalSpeed
                );
            }
            splashParticles.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            splashParticles.geometry.userData.velocities = velocities;
            splashParticles.visible = true;
        }

        function startBackflip() {
            if (isBackflipping) return;

            isBackflipping = true;
            marsAI.isExecutingUrgentAction = true; // pause AI actions during trick

            // Initial jump splash effect
            triggerSplashEffect();

            // Configure flip state
            backflipState = {
                t: 0,                   // elapsed seconds
                duration: 1.5,          // total backflip duration
                startPos: mars.position.clone(),
                radius: 1.6,            // horizontal arc radius
                height: 2.8,            // jump height
                startRotY: mars.rotation.y,
                startRotZ: mars.rotation.z,
                didLandSplash: false,
                didShake: false,
                didVapor: false
            };
        }

        function updateBackflip(deltaTime) {
            if (!isBackflipping || !backflipState) return;

            const s = backflipState;
            s.t += deltaTime;
            const k = Math.min(s.t / s.duration, 1);     // normalized 0..1
            const theta = k * Math.PI * 2;               // one full rotation

            // Offset along the long axis (forward direction) instead of circular XZ
            // Forward is derived from starting yaw (rotation.y)
            const forward = new THREE.Vector3(Math.sin(s.startRotY), 0, Math.cos(s.startRotY));
            const along = forward.clone().multiplyScalar(Math.cos(theta) * s.radius);

            // Vertical jump arc (simple smooth)
            const py = s.startPos.y + s.height * Math.sin(Math.PI * Math.min(k, 1));

            // Apply transform: start position + forward offset, keep Y arc
            const pos = s.startPos.clone().add(along);
            mars.position.set(pos.x, py, pos.z);
            mars.rotation.x = theta;           // flip around X axis
            mars.rotation.y = s.startRotY;     // keep yaw stable
            mars.rotation.z = 0;               // prevent shoulder roll

            // Landing effects near end
            if (k >= 0.98 && !s.didLandSplash) {
                s.didLandSplash = true;
                triggerSplashEffect();         // bigger splash can be tuned in triggerSplashEffect()
            }
            if (k >= 0.98 && !s.didShake) {
                s.didShake = true;
                shakeCamera(500, 0.6);         // 500ms earthquake shake
            }
            if (k >= 0.98 && !s.didVapor) {
                s.didVapor = true;
                triggerVaporMist(mars.position);
            }

            // Finish
            if (k >= 1) {
                isBackflipping = false;
                backflipState = null;
                mars.rotation.x = 0;
                mars.rotation.z = 0;           // ensure no residual roll
                marsAI.isExecutingUrgentAction = false;

                // Award points and message
                if (typeof marsStats.score === 'number') {
                    marsStats.score += 10000;
                } else {
                    marsStats.score = 10000;
                }
                showMessage('Congratulations! +10,000 points!');
            }
        }

        function triggerVaporMist(origin) {
            const particleCount = 80;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const material = new THREE.PointsMaterial({
                color: 0xCCCCCC,
                size: 0.25,
                transparent: true,
                opacity: 0.9,
                depthWrite: false
            });

            const velocities = [];
            for (let i = 0; i < particleCount; i++) {
                positions[i*3]   = origin.x;
                positions[i*3+1] = 0.2;
                positions[i*3+2] = origin.z;
                velocities[i] = new THREE.Vector3(
                    (Math.random()-0.5)*0.4,
                    Math.random()*0.8 + 0.4,
                    (Math.random()-0.5)*0.4
                );
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const points = new THREE.Points(geometry, material);
            scene.add(points);

            const start = Date.now();
            function tick() {
                const dt = 0.016;
                const arr = geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    arr[i*3]   += velocities[i].x * dt;
                    arr[i*3+1] += velocities[i].y * dt;
                    arr[i*3+2] += velocities[i].z * dt;
                    velocities[i].y -= 0.5 * dt; // gravity
                }
                geometry.attributes.position.needsUpdate = true;
                material.opacity = Math.max(0, material.opacity - 0.02);

                if (material.opacity > 0.05) {
                    requestAnimationFrame(tick);
                } else {
                    scene.remove(points);
                    geometry.dispose();
                    material.dispose();
                }
            }
            tick();
        }

        function isMarsInWater() {
            for (const pool of pools) {
                if (mars.position.distanceTo(pool.position) < 4) { // 4 is pool radius
                    return true;
                }
            }
            return false;
        }

        function createMars() {
            // MARS as a cube (placeholder)
            const marsGeometry = new THREE.BoxGeometry(1, 0.8, 1.5);
            const marsMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4B8B });
            mars = new THREE.Mesh(marsGeometry, marsMaterial);
            mars.position.set(0, 0.4, 0);
            mars.castShadow = true;
            mars.userData = { 
                type: 'mars',
                velocity: new THREE.Vector3(),
                targetPosition: null,
                isMoving: false
            };
            scene.add(mars);
        }
        
        function setupEventListeners() {
            // Mouse events
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('contextmenu', onRightClick);
            
            // Time speed control
            document.getElementById('timeSpeed').addEventListener('click', toggleTimeSpeed);
            // Sleep and Journal controls
            document.getElementById('sleepBtn').addEventListener('click', onSleepClick);
            document.getElementById('journalBtn').addEventListener('click', () => toggleJournal(true));
            document.getElementById('closeJournalBtn').addEventListener('click', () => toggleJournal(false));
            document.getElementById('splashBtn').addEventListener('click', onSplashClick);

            // Journal Tabs
            document.querySelectorAll('.journal-tab').forEach(tab => {
                tab.addEventListener('click', () => switchJournalTab(tab.dataset.tab));
            });

            // UI Toggle
            document.getElementById('toggle-log-btn').addEventListener('click', () => {
                const sidebar = document.getElementById('left-sidebar');
                const btn = document.getElementById('toggle-log-btn');
                sidebar.classList.toggle('collapsed');
                if (sidebar.classList.contains('collapsed')) {
                    btn.textContent = '▶';
                } else {
                    btn.textContent = '◀';
                }
            });
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
        }

        function toggleJournal(forceOpen) {
            const journal = document.getElementById('journal');
            const isOpen = journal.classList.contains('open');
            if (typeof forceOpen === 'boolean' ? forceOpen : !isOpen) {
                journal.classList.add('open');
                // When opening the journal, refresh the log list
                updateStoryLog(); 
                showMessage('Journal opened');
            } else {
                journal.classList.remove('open');
                showMessage('Journal closed');
            }
        }

        function switchJournalTab(tabId) {
            // Update tabs
            document.querySelectorAll('.journal-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabId);
            });
            // Update content panes
            document.querySelectorAll('.journal-pane').forEach(pane => {
                pane.classList.toggle('active', pane.id === `journal-${tabId}`);
            });
            showMessage(`Journal tab: ${tabId}`);
        }

        function onSplashClick() {
            if (isMarsInWater()) {
                // Manually trigger a splash action
                showMessage('You pressed Splash');
                marsAI.currentAction = 'splash';
                marsAI.isExecutingUrgentAction = true; // Prioritize this action
                marsAI.actionStartTime = Date.now();
                updateAIStatus('Having fun splashing!');
            } else {
                showMessage("MARS needs to be in the water to splash!");
            }
        }

        function onKeyDown(event) {
            // Space starts backflip combo when in water and not already flipping
            if (event.code === 'Space' && isMarsInWater() && !isBackflipping) {
                showMessage('You pressed Space: backflip!');
                startBackflip();
            }
        }

        function onSleepClick() {
            if (inDream) return;
            const allowSleep = marsStats.energy <= 0 || isNightHour(gameTime);
            if (!allowSleep) {
                showMessage("It's not night yet. MARS isn't sleepy.");
                return;
            }
            // Initiate sleep action immediately
            showMessage('You pressed Sleep');
            marsAI.currentAction = 'sleep';
            marsAI.isExecutingUrgentAction = true;
            marsAI.actionStartTime = Date.now();
            sleepStartHour = gameTime;
            updateAIStatus('Heading to sleep...');
            setMarsAutonomousTarget('sleep');
        }
        
        function onMouseClick(event) {
            if (!isGameStarted) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            for (let intersect of intersects) {
                if (intersect.object.userData.type === 'ground') {
                    setMarsTarget(intersect.point);
                    try {
                        showMessage(`Manual move to (${intersect.point.x.toFixed(1)}, ${intersect.point.z.toFixed(1)})`);
                    } catch (e) {
                        showMessage('Manual move set');
                    }
                    break;
                }
            }
        }
        
        function onRightClick(event) {
            event.preventDefault();
            if (!isGameStarted) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(rocks, true);
            
            if (intersects.length > 0) {
                const rock = intersects[0].object;
                if (mars.position.distanceTo(rock.position) < 3) {
                    interactWithRock(rock);
                } else {
                    showMessage('You right-clicked a rock, but it\'s too far. Move closer to interact.');
                }
            }
        }
        
        function setMarsTarget(position) {
            // Clamp target to inside the habitat
            const v = new THREE.Vector3(position.x, 0.4, position.z);
            const fromCenter = new THREE.Vector3(v.x, 0, v.z);
            const d = Math.sqrt(fromCenter.x*fromCenter.x + fromCenter.z*fromCenter.z);
            if (d > HABITAT_INNER_RADIUS) {
                fromCenter.setLength(HABITAT_INNER_RADIUS);
                v.x = fromCenter.x;
                v.z = fromCenter.z;
            }
            mars.userData.targetPosition = v;
            mars.userData.isMoving = true;
            
            // Create target indicator
            if (currentTarget) {
                scene.remove(currentTarget);
            }
            
            const targetGeometry = new THREE.RingGeometry(0.5, 0.7, 8);
            const targetMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.7
            });
            currentTarget = new THREE.Mesh(targetGeometry, targetMaterial);
            currentTarget.position.set(v.x, 0.1, v.z);
            currentTarget.position.y = 0.1;
            currentTarget.rotation.x = -Math.PI / 2;
            scene.add(currentTarget);
        }
        
        function interactWithRock(rock) {
            if (rock.userData.hasBeenTurned) {
                showMessage("This rock has already been turned over!");
                return;
            }
            
            rock.userData.hasBeenTurned = true;
            rock.rotation.z += Math.PI * 0.3; // Tilt the rock
            
            // Spawn beetles
            spawnBeetles(rock.position);
            showMessage("MARS found beetles! Right-click them to eat!");
        }
        
        function spawnBeetles(position) {
            const beetleCount = 3 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < beetleCount; i++) {
                const beetleGeometry = new THREE.SphereGeometry(0.3);
                const beetleMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F2F });
                const beetle = new THREE.Mesh(beetleGeometry, beetleMaterial);
                
                const angle = (i / beetleCount) * Math.PI * 2;
                const radius = 0.5 + Math.random() * 1;
                beetle.position.set(
                    position.x + Math.cos(angle) * radius,
                    0.1,
                    position.z + Math.sin(angle) * radius
                );
                
                beetle.userData = {
                    type: 'beetle',
                    spawnTime: Date.now(),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        0,
                        (Math.random() - 0.5) * 0.1
                    )
                };
                
                beetles.push(beetle);
                scene.add(beetle);
            }
        }

        // Spawn a small number of ground beetles that immediately flee: most scatter to another rock; one hangs out near origin
        function spawnFleeingBeetles(origin, count = 3, originRock = null) {
            // Choose a destination rock different from originRock (if provided)
            const candidateRocks = originRock ? rocks.filter(r => r !== originRock) : rocks.slice();
            const destRock = candidateRocks.length > 0 ? candidateRocks[Math.floor(Math.random() * candidateRocks.length)] : null;

            for (let i = 0; i < count; i++) {
                const beetleGeometry = new THREE.SphereGeometry(0.3);
                const beetleMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F2F });
                const beetle = new THREE.Mesh(beetleGeometry, beetleMaterial);

                // Start near the rock
                const angle = Math.random() * Math.PI * 2;
                const radius = 0.2 + Math.random() * 0.3;
                beetle.position.set(
                    origin.x + Math.cos(angle) * radius,
                    0.1,
                    origin.z + Math.sin(angle) * radius
                );

                // Decide behavior: one hangs out near origin, others scatter toward a destination rock (if available)
                if (i === 0) {
                    // Hangout beetle: loiters near origin
                    beetle.userData = {
                        type: 'beetle',
                        spawnTime: Date.now(),
                        velocity: new THREE.Vector3((Math.random()-0.5)*0.05, 0, (Math.random()-0.5)*0.05),
                        hangoutNear: true,
                        hangoutPos: new THREE.Vector3(origin.x, 0.1, origin.z)
                    };
                } else {
                    // Scatter beetles: pick target near another rock if possible, otherwise run away from MARS
                    let target = null;
                    if (destRock) {
                        target = destRock.position.clone();
                        target.x += (Math.random()-0.5) * 1.5;
                        target.z += (Math.random()-0.5) * 1.5;
                    }

                    const speed = 0.35 + Math.random() * 0.2;
                    let initialVel;
                    if (target) {
                        initialVel = target.clone().sub(beetle.position).normalize().multiplyScalar(speed);
                    } else {
                        // Fallback: run away from MARS
                        initialVel = beetle.position.clone().sub(mars.position).normalize().multiplyScalar(speed);
                    }

                    beetle.userData = {
                        type: 'beetle',
                        spawnTime: Date.now(),
                        velocity: initialVel,
                        scatterTarget: target
                    };
                }

                beetles.push(beetle);
                scene.add(beetle);
            }
        }

        // Lightly nudge a rock to make beetles scatter without flipping it
        function nudgeRock(rock) {
            const now = Date.now();
            const cooldown = 4000; // 4s cooldown per rock
            if (!rock.userData.lastNudgeTime || (now - rock.userData.lastNudgeTime) > cooldown) {
                rock.userData.lastNudgeTime = now;
                // Tiny wiggle animation
                const originalZ = rock.rotation.z;
                const targetZ = originalZ + Math.PI * 0.06;
                const start = Date.now();
                const duration = 250;
                function wiggle() {
                    const t = Math.min((Date.now() - start) / duration, 1);
                    const ease = t < 0.5 ? (2*t*t) : (-1 + (4 - 2*t)*t); // simple ease in-out
                    rock.rotation.z = originalZ + (targetZ - originalZ) * ease;
                    if (t < 1) {
                        requestAnimationFrame(wiggle);
                    } else {
                        rock.rotation.z = originalZ; // return to rest
                    }
                }
                wiggle();

                // Spawn ~3 fleeing beetles, with destination behavior
                spawnFleeingBeetles(rock.position, 3, rock);
                showMessage('MARS nudges the rock — beetles scatter! 🪲');
            }
        }
        
        function updateMars(deltaTime) {
            if (!mars.userData.isMoving || !mars.userData.targetPosition) return;
            
            const target = mars.userData.targetPosition;
            const direction = target.clone().sub(mars.position).normalize();
            const distance = mars.position.distanceTo(target);
            
            if (distance < 0.5) {
                mars.userData.isMoving = false;
                mars.userData.targetPosition = null;
                if (currentTarget) {
                    scene.remove(currentTarget);
                    currentTarget = null;
                }
                return;
            }
            
            // Apply time multiplier to movement speed
            const speed = 3 * deltaTime * timeMultiplier;
            mars.position.add(direction.multiplyScalar(speed));

            // Keep MARS inside habitat
            const center = new THREE.Vector3(0, mars.position.y, 0);
            const toPos = mars.position.clone().sub(center);
            const dist = Math.sqrt(toPos.x*toPos.x + toPos.z*toPos.z);
            if (dist > HABITAT_INNER_RADIUS) {
                toPos.setLength(HABITAT_INNER_RADIUS);
                mars.position.set(toPos.x, mars.position.y, toPos.z);
                // Stop at boundary to avoid jittering forward
                mars.userData.isMoving = false;
                mars.userData.targetPosition = null;
                if (currentTarget) { scene.remove(currentTarget); currentTarget = null; }
            }
            
            // Apply time multiplier to jumping animation
            mars.position.y = 0.4 + Math.sin(Date.now() * 0.01 * timeMultiplier) * 0.1;
            
            // Face movement direction
            mars.lookAt(target.x, mars.position.y, target.z);
            
            // Update camera to follow MARS
            updateCamera();
        }
        
        function updateCamera() {
            const targetCameraPos = mars.position.clone().add(new THREE.Vector3(30, 30, 30));
            // Apply time multiplier to camera smoothing
            const smoothness = 0.1 * timeMultiplier;
            camera.position.lerp(targetCameraPos, Math.min(smoothness, 0.5)); // Cap max smoothness
            camera.lookAt(mars.position);
        }

        // Update environment lighting and background based on time of day
        function updateEnvironment() {
            // Normalize time to 0..24
            const t = ((gameTime % 24) + 24) % 24;

            // Determine phase weights
            const isDay = t >= 7 && t < 18;
            const isNight = t >= 20 || t < 5;
            const isSunrise = t >= 5 && t < 7;
            const isSunset = t >= 18 && t < 20;

            // Target values
            let ambientIntensity = 0.6;
            let sunIntensity = 0.8;
            let skyDay = new THREE.Color(0x87CEEB); // sky blue
            let skyNight = new THREE.Color(0x0b1020); // deep night blue

            // Interpolate for sunrise and sunset
            if (isSunrise) {
                const k = (t - 5) / 2; // 0..1
                ambientIntensity = 0.2 + k * (0.6 - 0.2);
                sunIntensity = 0.2 + k * (0.8 - 0.2);
                const c = skyNight.clone().lerp(skyDay, k);
                scene.background = c;
            } else if (isSunset) {
                const k = (t - 18) / 2; // 0..1
                ambientIntensity = 0.6 + k * (0.2 - 0.6);
                sunIntensity = 0.8 + k * (0.2 - 0.8);
                const c = skyDay.clone().lerp(skyNight, k);
                scene.background = c;
            } else if (isDay) {
                ambientIntensity = 0.6;
                sunIntensity = 0.8;
                scene.background = skyDay;
            } else if (isNight) {
                ambientIntensity = 0.2;
                sunIntensity = 0.2;
                scene.background = skyNight;
            }

            if (ambientLight) ambientLight.intensity = ambientIntensity;
            if (sunLight) {
                sunLight.intensity = sunIntensity;
                // Move sun across the sky: map 6..18 to above horizon arc
                const dayAngle = ((t - 6) / 12) * Math.PI; // 0..PI
                const radius = 80;
                // Clamp for night
                const angle = Math.max(0, Math.min(Math.PI, dayAngle));
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                sunLight.position.set(x, y, x * 0.6);
                sunLight.lookAt(0, 0, 0);
            }
        }

        function isNightHour(hour) {
            const h = ((hour % 24) + 24) % 24;
            return h >= 20 || h < 5; // 8pm - 5am
        }

        function shakeCamera(durationMs = 500, magnitude = 0.5) {
            const start = Date.now();
            const base = camera.position.clone();

            function tick() {
                const elapsed = Date.now() - start;
                const k = Math.min(elapsed / durationMs, 1);
                const damp = 1 - k;

                camera.position.set(
                    base.x + (Math.random() - 0.5) * magnitude * damp,
                    base.y + (Math.random() - 0.5) * magnitude * damp,
                    base.z + (Math.random() - 0.5) * magnitude * damp
                );

                if (k < 1) {
                    requestAnimationFrame(tick);
                } else {
                    camera.position.copy(base);
                }
            }
            tick();
        }
        
        function updateBeetles(deltaTime) {
            const currentTime = Date.now();
            
            // Handle beetle spawning
            manageBeetleSpawning(currentTime);
            
            // Handle rock regeneration
            manageRockRegeneration(currentTime);

            // Periodically trigger a poop swarm
            triggerPoopSwarm(currentTime);
            
            beetles.forEach((beetle, index) => {
                const age = currentTime - beetle.userData.spawnTime;
                
                // Apply time multiplier to beetle lifespan
                let lifespanMs = 15000 / timeMultiplier;
                
                // Swarming beetles live longer
                if (beetle.userData.isSwarmingRock) {
                    lifespanMs = 30000 / timeMultiplier; // 30 seconds for swarming beetles
                }
                
                if (age > lifespanMs) {
                    // Remove from rock's swarm if applicable
                    if (beetle.userData.swarmRock) {
                        const rock = beetle.userData.swarmRock;
                        const swarmIndex = rock.userData.regenBeetles.indexOf(beetle);
                        if (swarmIndex > -1) {
                            rock.userData.regenBeetles.splice(swarmIndex, 1);
                        }
                    }
                    
                    scene.remove(beetle);
                    beetles.splice(index, 1);
                    return;
                }
                
                // Handle different beetle behaviors
                if (beetle.userData.isFlying) {
                    handleFlyingBeetle(beetle);
                } else if (beetle.userData.isSwarmingRock) {
                    handleSwarmingBeetle(beetle, currentTime);
                } else {
                    handleGroundBeetle(beetle);
                }
                
                // MARS eating logic (only for ground beetles, not swarming or flying ones)
                if (!beetle.userData.isFlying && !beetle.userData.isSwarmingRock) {
                    handleBeetleEating(beetle, index, currentTime);
                }
            });
        }
        
        function manageRockRegeneration(currentTime) {
            rocks.forEach(rock => {
                const timeSinceRegen = currentTime - rock.userData.lastRegenTime;
                const adjustedInterval = rock.userData.regenInterval / timeMultiplier;
                
                // Check if rock should start regenerating
                if (rock.userData.hasBeenTurned && 
                    !rock.userData.isRegenerating && 
                    timeSinceRegen > adjustedInterval) {
                    
                    // Directly complete regeneration at interval to meet 20s requirement
                    completeRockRegeneration(rock);
                }
                
                // (No extra delay beyond interval; rollback happens immediately now)
            });
        }
        
        function startRockRegeneration(rock) {
            rock.userData.isRegenerating = true;
            
            // Spawn 5-8 swarming beetles around the rock
            const beetleCount = 5 + Math.floor(Math.random() * 4);
            
            for (let i = 0; i < beetleCount; i++) {
                const beetleGeometry = new THREE.SphereGeometry(0.2); // Slightly smaller
                const beetleMaterial = new THREE.MeshLambertMaterial({ color: 0x4F4F2F }); // Darker color
                const beetle = new THREE.Mesh(beetleGeometry, beetleMaterial);
                
                // Start beetles at random positions around the rock
                const angle = (i / beetleCount) * Math.PI * 2;
                const radius = 1 + Math.random() * 0.5;
                beetle.position.set(
                    rock.position.x + Math.cos(angle) * radius,
                    0.3 + Math.random() * 0.4, // Slightly elevated
                    rock.position.z + Math.sin(angle) * radius
                );
                
                beetle.userData = {
                    type: 'beetle',
                    spawnTime: Date.now(),
                    isSwarmingRock: true,
                    swarmRock: rock,
                    swarmAngle: angle,
                    swarmRadius: radius,
                    swarmSpeed: 0.02 + Math.random() * 0.01
                };
                
                beetles.push(beetle);
                scene.add(beetle);
                rock.userData.regenBeetles.push(beetle);
            }
            
            // Change rock color to indicate regeneration
            rock.material.color.setHex(0x8B7355); // Brownish color
            
            showMessage(`Rock is regenerating beetles! 🪨🪲`, Math.max(500, 2000 / timeMultiplier));
        }
        
        function completeRockRegeneration(rock) {
            // Reset rock status
            rock.userData.hasBeenTurned = false;
            rock.userData.isRegenerating = false;
            rock.userData.lastRegenTime = Date.now();
            // Smoothly roll back to normal rotation
            const startRot = rock.rotation.z;
            const endRot = 0;
            const startTime = Date.now();
            const duration = 600; // ms roll-back
            function animateRollback() {
                const t = Math.min(1, (Date.now() - startTime) / duration);
                // ease in-out
                const ease = t < 0.5 ? (2*t*t) : (-1 + (4 - 2*t)*t);
                rock.rotation.z = startRot + (endRot - startRot) * ease;
                if (t < 1) requestAnimationFrame(animateRollback);
            }
            animateRollback();
            
            // Return to normal color
            rock.material.color.setHex(0x696969);
            
            // Convert swarming beetles to normal ground beetles
            rock.userData.regenBeetles.forEach(beetle => {
                beetle.userData.isSwarmingRock = false;
                beetle.userData.swarmRock = null;
                beetle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    0,
                    (Math.random() - 0.5) * 0.1
                );
                beetle.position.y = 0.1; // Ground level
                
                // Change to normal beetle appearance
                beetle.geometry.dispose();
                beetle.geometry = new THREE.SphereGeometry(0.3);
                beetle.material.color.setHex(0x2F4F2F);
            });
            
            rock.userData.regenBeetles = [];

            // Ensure some bugs are present under the rock upon reset
            spawnBeetles(rock.position);
            
            showMessage(`Rock refreshed and moved! Ready for more beetles! 🪨✨`, Math.max(500, 2500 / timeMultiplier));
        }
        
        function moveRockToNewLocation(rock) {
            // Find a new random location that's not too close to other rocks
            let newPos;
            let attempts = 0;
            
            do {
                const angle = Math.random() * Math.PI * 2;
                const radius = 3 + Math.random() * 12; // 3-15 units from center
                newPos = {
                    x: Math.cos(angle) * radius,
                    z: Math.sin(angle) * radius
                };
                attempts++;
            } while (attempts < 20 && isTooCloseToOtherRocks(rock, newPos));
            
            rock.position.set(newPos.x, 0.25, newPos.z);
        }
        
        function isTooCloseToOtherRocks(currentRock, newPos) {
            return rocks.some(otherRock => {
                if (otherRock === currentRock) return false;
                const distance = Math.sqrt(
                    Math.pow(otherRock.position.x - newPos.x, 2) + 
                    Math.pow(otherRock.position.z - newPos.z, 2)
                );
                return distance < 3; // Minimum 3 units apart
            });
        }
        
        function handleSwarmingBeetle(beetle, currentTime) {
            const rock = beetle.userData.swarmRock;
            if (!rock) return;
            
            // Update swarm angle for circular motion
            beetle.userData.swarmAngle += beetle.userData.swarmSpeed * timeMultiplier;
            
            // Vary the radius slightly for natural movement
            const radiusVariation = Math.sin(currentTime * 0.003 + beetle.userData.swarmAngle) * 0.2;
            const currentRadius = beetle.userData.swarmRadius + radiusVariation;
            
            // Circular motion around the rock
            beetle.position.x = rock.position.x + Math.cos(beetle.userData.swarmAngle) * currentRadius;
            beetle.position.z = rock.position.z + Math.sin(beetle.userData.swarmAngle) * currentRadius;
            
            // Bob up and down slightly
            beetle.position.y = 0.3 + Math.sin(currentTime * 0.005 + beetle.userData.swarmAngle) * 0.1;
        }
        
        function handleFlyingBeetle(beetle) {
            // Existing flying logic
            const direction = beetle.userData.landingTarget.clone().sub(beetle.position).normalize();
            const flySpeed = 0.05 * timeMultiplier;
            beetle.position.add(direction.multiplyScalar(flySpeed));
            // Clamp to habitat radius while flying
            const dx = beetle.position.x, dz = beetle.position.z;
            const r = Math.sqrt(dx*dx + dz*dz);
            const limit = HABITAT_INNER_RADIUS;
            // If beyond outer radius, drift back toward center
            if (r > HABITAT_RADIUS) {
                const inward = new THREE.Vector3(-dx, 0, -dz).normalize();
                beetle.position.add(inward.multiplyScalar(0.1));
            }
            if (r > limit) {
                const ang = Math.atan2(dz, dx);
                beetle.position.x = Math.cos(ang) * limit;
                beetle.position.z = Math.sin(ang) * limit;
            }
            
            if (beetle.position.distanceTo(beetle.userData.landingTarget) < 0.5) {
                beetle.userData.isFlying = false;
                beetle.position.y = 0.1;
                beetle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    0,
                    (Math.random() - 0.5) * 0.1
                );
            }
        }
        
        function handleGroundBeetle(beetle) {
            // Steering for scatter and hangout behavior
            // Attraction: beetles like to skurry to the nearest poop pile
            let poopAttraction = null;
            if (poopSpots.length > 0) {
                // find nearest poop lump
                let nearest = null;
                let bestD2 = Infinity;
                for (const p of poopSpots) {
                    const dx = p.position.x - beetle.position.x;
                    const dz = p.position.z - beetle.position.z;
                    const d2 = dx*dx + dz*dz;
                    if (d2 < bestD2) { bestD2 = d2; nearest = p; }
                }
                if (nearest) poopAttraction = nearest.position.clone();
            }
            // Swarm behavior: head to selected poopSpot then hide
            if (beetle.userData.behavior === 'swarm_to_poop' && beetle.userData.swarmTarget) {
                const dir = beetle.userData.swarmTarget.clone().sub(beetle.position);
                const dist = dir.length();
                if (dist > 0.01) {
                    dir.normalize();
                    beetle.userData.velocity.lerp(dir.multiplyScalar(0.22), 0.12 * timeMultiplier);
                }
                // Reached swarm area
                if (dist < 0.6) {
                    if (!beetle.userData.swarmLingerUntil) {
                        beetle.userData.swarmLingerUntil = Date.now() + 1000; // linger ~1s
                        // slow and jitter slightly
                        beetle.userData.velocity.multiplyScalar(0.2);
                    }
                    // After linger, pick a hide target
                    if (Date.now() > beetle.userData.swarmLingerUntil) {
                        const hide = pickHideTargetNear(beetle.position);
                        if (hide) {
                            beetle.userData.behavior = 'hide_after_swarm';
                            beetle.userData.scatterTarget = hide;
                            beetle.userData.swarmTarget = null;
                            beetle.userData.swarmLingerUntil = null;
                        } else {
                            // fallback to nearest poop attraction
                            if (poopAttraction) {
                                beetle.userData.scatterTarget = poopAttraction.clone();
                                beetle.userData.behavior = 'hide_after_swarm';
                            } else {
                                beetle.userData.behavior = null;
                            }
                        }
                    }
                }
            } else if (beetle.userData.behavior === 'hide_after_swarm' && beetle.userData.scatterTarget) {
                const dir = beetle.userData.scatterTarget.clone().sub(beetle.position);
                const dist = dir.length();
                if (dist > 0.01) {
                    dir.normalize();
                    beetle.userData.velocity.lerp(dir.multiplyScalar(0.25), 0.1 * timeMultiplier);
                }
                if (dist < 0.5) {
                    // Arrived at hide location -> hang out there
                    beetle.userData.hangoutNear = true;
                    beetle.userData.hangoutPos = beetle.userData.scatterTarget.clone();
                    beetle.userData.scatterTarget = null;
                    beetle.userData.behavior = null;
                    beetle.userData.velocity.multiplyScalar(0.2);
                }
            } else if (beetle.userData.scatterTarget) {
                const dir = beetle.userData.scatterTarget.clone().sub(beetle.position);
                const dist = dir.length();
                if (dist > 0.01) {
                    dir.normalize();
                    // steer toward target
                    beetle.userData.velocity.lerp(dir.multiplyScalar(0.25), 0.1 * timeMultiplier);
                    // arrive and convert to hangout near target rock
                    if (dist < 0.6) {
                        beetle.userData.hangoutNear = true;
                        beetle.userData.hangoutPos = beetle.userData.scatterTarget.clone();
                        beetle.userData.scatterTarget = null;
                        // slow down upon arriving
                        beetle.userData.velocity.multiplyScalar(0.2);
                    }
                }
            } else if (beetle.userData.hangoutNear && beetle.userData.hangoutPos) {
                // Gentle wander around hangout position
                const toHome = beetle.userData.hangoutPos.clone().sub(beetle.position);
                if (toHome.length() > 0.8) {
                    // pull back toward hangout
                    toHome.normalize();
                    beetle.userData.velocity.add(toHome.multiplyScalar(0.02));
                } else if (Math.random() < 0.02 * timeMultiplier) {
                    // random small drift
                    beetle.userData.velocity.add(new THREE.Vector3((Math.random()-0.5)*0.02, 0, (Math.random()-0.5)*0.02));
                }
                // dampen velocity for loitering
                beetle.userData.velocity.multiplyScalar(0.98);
            } else {
                // Existing ground movement logic
                if (Math.random() < (0.02 * timeMultiplier)) {
                    beetle.userData.velocity.set(
                        (Math.random() - 0.5) * 0.1,
                        0,
                        (Math.random() - 0.5) * 0.1
                    );
                }
            }

            // Apply poop attraction gently if present
            if (poopAttraction) {
                const dirToPoop = poopAttraction.clone().sub(beetle.position);
                const d = dirToPoop.length();
                if (d > 0.01) {
                    dirToPoop.normalize();
                    // stronger pull when closer
                    const pull = Math.min(0.08, 0.03 + (1/Math.max(d,0.5))*0.01);
                    beetle.userData.velocity.add(dirToPoop.multiplyScalar(pull * timeMultiplier));
                }
            }

            const scaledVelocity = beetle.userData.velocity.clone().multiplyScalar(timeMultiplier);
            beetle.position.add(scaledVelocity);

            // Keep beetles inside habitat: clamp and reflect velocity
            const dx = beetle.position.x;
            const dz = beetle.position.z;
            const r2 = dx*dx + dz*dz;
            const limit = HABITAT_INNER_RADIUS;
            // If beyond outer radius, drift back toward center
            const r = Math.sqrt(r2);
            if (r > HABITAT_RADIUS) {
                const inward = new THREE.Vector3(-dx, 0, -dz).normalize();
                beetle.userData.velocity.add(inward.multiplyScalar(0.12));
            }
            if (r2 > limit*limit) {
                const ang = Math.atan2(dz, dx);
                beetle.position.x = Math.cos(ang) * limit;
                beetle.position.z = Math.sin(ang) * limit;
                // Bounce back inward
                const inward = new THREE.Vector3(-Math.cos(ang), 0, -Math.sin(ang));
                beetle.userData.velocity.add(inward.multiplyScalar(0.1));
            }
        }
        
        function handleBeetleEating(beetle, index, currentTime) {
            const distanceToMars = mars.position.distanceTo(beetle.position);
            const adjustedCooldown = BEETLE_EATING_COOLDOWN / timeMultiplier;
            
            if (distanceToMars < 2.0 && currentTime - lastBeetleEaten > adjustedCooldown) {
                scene.remove(beetle);
                beetles.splice(index, 1);
                feedMars();
                lastBeetleEaten = currentTime;
                showMessage("MARS ate a beetle! 🪲", Math.max(500, 1500 / timeMultiplier));
                
                if (marsAI.currentAction === 'hunting_beetle') {
                    marsAI.isExecutingUrgentAction = false;
                    marsAI.currentAction = 'idle';
                    updateAIStatus('Beetle caught!');
                }
                return true;
            }
            return false;
        }
        
        function manageBeetleSpawning(currentTime) {
            // Adjust spawn interval with time multiplier
            const adjustedInterval = beetleSpawner.spawnInterval / timeMultiplier;
            
            if (currentTime - beetleSpawner.lastSpawn > adjustedInterval) {
                beetleSpawner.lastSpawn = currentTime;
                
                // Only spawn if we have room and random chance succeeds
                if (beetles.length < beetleSpawner.maxBeetles && Math.random() < beetleSpawner.spawnChance) {
                    spawnFlyingBeetle();
                }
            }
        }

        // Periodically choose a few ground beetles to swarm to a poop pile
        function triggerPoopSwarm(currentTime) {
            const interval = POOP_SWARM_INTERVAL_MS / timeMultiplier;
            if (currentTime - lastPoopSwarmTime < interval) return;
            if (poopSpots.length === 0 || beetles.length === 0) return;

            lastPoopSwarmTime = currentTime;

            // Pick 1-3 ground beetles that are not flying or already in a special behavior
            const candidates = beetles.filter(b => !b.userData.isFlying && !b.userData.isSwarmingRock && !b.userData.behavior);
            if (candidates.length === 0) return;

            const count = Math.min(1 + Math.floor(Math.random() * 3), candidates.length);
            for (let i = 0; i < count; i++) {
                const idx = Math.floor(Math.random() * candidates.length);
                const b = candidates.splice(idx, 1)[0];
                // Choose a random poop spot to swarm to
                const ps = poopSpots[Math.floor(Math.random() * poopSpots.length)];
                if (!ps) continue;
                b.userData.behavior = 'swarm_to_poop';
                b.userData.swarmTarget = ps.position.clone();
                // give it a little initial push toward target
                const dir = b.userData.swarmTarget.clone().sub(b.position).normalize();
                b.userData.velocity.add(dir.multiplyScalar(0.1));
            }
        }

        // Choose a nearby hide target under a rock or another poop pile
        function pickHideTargetNear(origin) {
            const options = [];
            // Nearby rocks
            for (const r of rocks) {
                const pos = r.position.clone();
                // small offset around rock
                const ang = Math.random() * Math.PI * 2;
                pos.x += Math.cos(ang) * 0.6;
                pos.z += Math.sin(ang) * 0.6;
                options.push(pos);
            }
            // Other poop piles
            for (const p of poopSpots) {
                const pos = p.position.clone();
                const ang = Math.random() * Math.PI * 2;
                pos.x += Math.cos(ang) * 0.4;
                pos.z += Math.sin(ang) * 0.4;
                options.push(pos);
            }
            if (options.length === 0) return null;

            // Choose the closest hide option to origin
            let best = null;
            let bestD2 = Infinity;
            for (const pos of options) {
                const dx = pos.x - origin.x;
                const dz = pos.z - origin.z;
                const d2 = dx*dx + dz*dz;
                if (d2 < bestD2) { bestD2 = d2; best = pos; }
            }
            if (!best) return null;

            // Clamp to habitat
            const len = Math.sqrt(best.x*best.x + best.z*best.z);
            if (len > HABITAT_INNER_RADIUS) {
                best.x = (best.x / len) * HABITAT_INNER_RADIUS;
                best.z = (best.z / len) * HABITAT_INNER_RADIUS;
            }
            best.y = 0.1;
            return best;
        }
        
        function spawnFlyingBeetle() {
            const beetleGeometry = new THREE.SphereGeometry(0.3);
            const beetleMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F2F });
            const beetle = new THREE.Mesh(beetleGeometry, beetleMaterial);
            
            // Spawn from habitat edge at flying height
            const angle = Math.random() * Math.PI * 2;
            const spawnDistance = HABITAT_INNER_RADIUS; // at the border
            
            beetle.position.set(
                Math.cos(angle) * spawnDistance,
                3 + Math.random() * 2, // Flying height (3-5 units high)
                Math.sin(angle) * spawnDistance
            );
            
            // Random landing target inside habitat
            const landingAngle = Math.random() * Math.PI * 2;
            const landingRadius = Math.random() * (HABITAT_INNER_RADIUS - 1);
            const landingTarget = new THREE.Vector3(
                Math.cos(landingAngle) * landingRadius,
                0.1,
                Math.sin(landingAngle) * landingRadius
            );
            
            beetle.userData = {
                type: 'beetle',
                spawnTime: Date.now(),
                isFlying: true,
                landingTarget: landingTarget,
                velocity: null // Will be set when landed
            };
            
            beetles.push(beetle);
            scene.add(beetle);
            
            // Announce new beetle arrival occasionally
            if (Math.random() < 0.3) {
                showMessage("Beetles are flying in! 🪲✈️", Math.max(500, 1000 / timeMultiplier));
            }
        }
        
        function feedMars() {
            marsStats.hunger = Math.max(0, marsStats.hunger - 15);
            marsStats.thirst = Math.max(0, marsStats.thirst - 10);
            marsStats.happiness = Math.min(100, marsStats.happiness + 20);
        }
        
        // Frogs are tastier: bigger hunger relief and happiness boost
        function feedMarsFrog() {
            marsStats.hunger = Math.max(0, marsStats.hunger - 25);
            marsStats.thirst = Math.max(0, marsStats.thirst - 5);
            marsStats.happiness = Math.min(100, marsStats.happiness + 25);
        }
        
        function updateBeetles(deltaTime) {
            beetles.forEach((beetle, index) => {
                const age = Date.now() - beetle.userData.spawnTime;
                
                // Remove beetles after 15 seconds
                if (age > 15000) {
                    scene.remove(beetle);
                    beetles.splice(index, 1);
                    return;
                }
                
                // Move beetles randomly
                beetle.position.add(beetle.userData.velocity);
                
                // Change direction occasionally
                if (Math.random() < 0.02) {
                    beetle.userData.velocity.set(
                        (Math.random() - 0.5) * 0.1,
                        0,
                        (Math.random() - 0.5) * 0.1
                    );
                }
                
                // Check if MARS catches the beetle
                if (mars.position.distanceTo(beetle.position) < 1) {
                    scene.remove(beetle);
                    beetles.splice(index, 1);
                    feedMars();
                    showMessage("MARS ate a beetle! 🪲");
                }
            });
        }
        
        function updateMarsAI(deltaTime) {
            const currentTime = Date.now();
            
            // Check for nearby beetles (only ground beetles, not flying or swarming ones)
            const nearbyGroundBeetles = beetles.filter(beetle => 
                !beetle.userData.isFlying && 
                !beetle.userData.isSwarmingRock &&
                mars.position.distanceTo(beetle.position) < 8
            );

            // If hunting and close to an unturned rock, nudge it to spawn a few beetles
            if (marsAI.currentAction === 'hunt') {
                const closeRock = rocks.find(rock => !rock.userData.hasBeenTurned && mars.position.distanceTo(rock.position) < 2.5);
                if (closeRock) {
                    nudgeRock(closeRock);
                }
            }
            
            if (nearbyGroundBeetles.length > 0 && marsAI.currentAction !== 'hunting_beetle') {
                // Override current action to hunt beetles
                marsAI.currentAction = 'hunting_beetle';
                marsAI.isExecutingUrgentAction = true;
                marsAI.actionStartTime = currentTime;
                updateAIStatus('🪲 Spotted beetles!');
                
                // Target the closest beetle
                const closestBeetle = nearbyGroundBeetles.reduce((closest, beetle) => 
                    mars.position.distanceTo(beetle.position) < mars.position.distanceTo(closest.position) ? beetle : closest
                );
                setMarsTarget(closestBeetle.position);
                return;
            }
            
            // If currently hunting but no beetles available, look for regenerating rocks
            if (marsAI.currentAction === 'hunting_beetle' && nearbyGroundBeetles.length === 0) {
                const regeneratingRocks = rocks.filter(rock => 
                    rock.userData.isRegenerating && 
                    mars.position.distanceTo(rock.position) < 12
                );
                
                if (regeneratingRocks.length > 0) {
                    const closestRock = regeneratingRocks.reduce((closest, rock) => 
                        mars.position.distanceTo(rock.position) < mars.position.distanceTo(closest.position) ? rock : closest
                    );
                    
                    updateAIStatus('🪨 Waiting for beetles to emerge...');
                    const waitPos = closestRock.position.clone();
                    waitPos.x += (Math.random() - 0.5) * 4;
                    waitPos.z += (Math.random() - 0.5) * 4;
                    setMarsTarget(waitPos);
                } else {
                    // No beetles or regenerating rocks nearby, return to normal behavior
                    marsAI.isExecutingUrgentAction = false;
                    marsAI.currentAction = 'idle';
                    updateAIStatus('No beetles around...');
                }
            }
            
            // Think more frequently with time multiplier
            const adjustedThoughtInterval = marsAI.thoughtInterval / timeMultiplier;
            if (currentTime - marsAI.lastThoughtTime > adjustedThoughtInterval) {
                marsAI.lastThoughtTime = currentTime;
                evaluateNeeds();
            }
            
            // Execute current action
            executeCurrentAction(deltaTime);
            
            // Update UI
            updateActionQueueUI();
        }
        
        function evaluateNeeds() {
            let urgentActions = [];
            let normalActions = [...marsAI.actionQueue];
            
            // Check for urgent needs (>50% threshold)
            if (marsStats.hunger > 50) {
                urgentActions.push({ action: 'hunt', priority: 4, reason: 'Very hungry!' });
            }
            if (marsStats.thirst > 50) {
                urgentActions.push({ action: 'drink', priority: 3, reason: 'Very thirsty!' });
            }
            if (marsStats.bladder > 50) {
                urgentActions.push({ action: 'pee', priority: 2, reason: 'Need to pee!' });
            }
            if (marsStats.bowel > 50) {
                urgentActions.push({ action: 'poop', priority: 1, reason: 'Need to poop!' });
            }
            // Low energy -> sleep
            if (marsStats.energy <= 0) {
                urgentActions = [{ action: 'sleep', priority: 0, reason: 'Exhausted! Going to sleep...' }];
            } else if (marsStats.energy < 20 && isNightHour(gameTime)) {
                // Only encourage sleep at night unless fully exhausted
                urgentActions.push({ action: 'sleep', priority: 0, reason: 'Very tired! Need sleep.' });
            }
            
            // Sort urgent actions by priority (lower number = higher priority)
            urgentActions.sort((a, b) => a.priority - b.priority);
            
            if (urgentActions.length > 0 && !marsAI.isExecutingUrgentAction) {
                // Switch to urgent action
                const urgentAction = urgentActions[0];
                marsAI.currentAction = urgentAction.action;
                marsAI.isExecutingUrgentAction = true;
                marsAI.actionStartTime = Date.now();
                if (urgentAction.action === 'sleep') {
                    sleepStartHour = gameTime;
                }
                
                updateAIStatus(`🚨 ${urgentAction.reason}`);
                setMarsAutonomousTarget(urgentAction.action);
            } else if (!marsAI.isExecutingUrgentAction) {
                // Continue with normal rotation
                rotateActionQueue();
            }
        }
        
        function rotateActionQueue() {
            // Move to next action in queue
            marsAI.queueIndex = (marsAI.queueIndex + 1) % marsAI.actionQueue.length;
            marsAI.currentAction = marsAI.actionQueue[marsAI.queueIndex];
            marsAI.actionStartTime = Date.now();
            
            updateAIStatus('Following routine');
            setMarsAutonomousTarget(marsAI.currentAction);
        }
        
        function executeCurrentAction(deltaTime) {
            const baseActionDuration = ACTIONS[marsAI.currentAction]?.duration || 5000;
            // Adjust action duration based on time multiplier
            const actionDuration = baseActionDuration / timeMultiplier;
            const elapsed = Date.now() - marsAI.actionStartTime;
            
            if (elapsed > actionDuration) {
                completeAction(marsAI.currentAction);
                
                if (marsAI.isExecutingUrgentAction) {
                    marsAI.isExecutingUrgentAction = false;
                    updateAIStatus('Need satisfied!');
                }
                
                // Don't immediately start next action, wait for next evaluation
                marsAI.currentAction = 'idle';
            }
        }
        
        function setMarsAutonomousTarget(actionType) {
            let targetPos = null;
            
            switch(actionType) {
                case 'drink':
                    if (pools.length > 0) {
                        const pool = pools[Math.floor(Math.random() * pools.length)];
                        targetPos = pool.position.clone();
                        targetPos.x += (Math.random() - 0.5) * 3;
                        targetPos.z += (Math.random() - 0.5) * 3;
                    }
                    break;
                    
                case 'hunt':
                    // Go to a rock that hasn't been turned
                    const availableRocks = rocks.filter(rock => !rock.userData.hasBeenTurned);
                    if (availableRocks.length > 0) {
                        const rock = availableRocks[Math.floor(Math.random() * availableRocks.length)];
                        targetPos = rock.position.clone();
                        targetPos.x += (Math.random() - 0.5) * 2;
                        targetPos.z += (Math.random() - 0.5) * 2;
                    }
                    break;
                    
                case 'poop':
                case 'pee':
                    // Go to edge of habitat
                    const angle = Math.random() * Math.PI * 2;
                    targetPos = new THREE.Vector3(
                        Math.cos(angle) * 15,
                        0.4,
                        Math.sin(angle) * 15
                    );
                    break;
                    
                case 'explore':
                    // Random location in habitat
                    const exploreAngle = Math.random() * Math.PI * 2;
                    const exploreRadius = Math.random() * 12;
                    targetPos = new THREE.Vector3(
                        Math.cos(exploreAngle) * exploreRadius,
                        0.4,
                        Math.sin(exploreAngle) * exploreRadius
                    );
                    break;
                    
                case 'rest':
                    // Stay near current position
                    targetPos = mars.position.clone();
                    targetPos.x += (Math.random() - 0.5) * 2;
                    targetPos.z += (Math.random() - 0.5) * 2;
                    break;
            }
            
            if (targetPos) {
                setMarsTarget(targetPos);
            }
        }
        
        function completeAction(actionType) {
            switch(actionType) {
                case 'drink':
                    marsStats.thirst = Math.max(0, marsStats.thirst - 30);
                    marsStats.happiness = Math.min(100, marsStats.happiness + 10);
                    showMessage("MARS had a refreshing drink! 💧", Math.max(500, 2000 / timeMultiplier));
                    break;
                    
                case 'hunt':
                    // Auto-interact with nearby rock with time-adjusted delay
                    const huntingDelay = Math.max(50, 300 / timeMultiplier);
                    setTimeout(() => {
                        const nearbyRock = rocks.find(rock => 
                            !rock.userData.hasBeenTurned && 
                            mars.position.distanceTo(rock.position) < 4
                        );
                        if (nearbyRock) {
                            interactWithRock(nearbyRock);
                        }
                    }, huntingDelay);
                    break;
                    
                case 'hunting_beetle':
                    // Beetle hunting completed - either caught beetle or lost it
                    marsStats.happiness = Math.min(100, marsStats.happiness + 5);
                    break;
                    
                case 'poop':
                    marsStats.bowel = Math.max(0, marsStats.bowel - 60);
                    marsStats.happiness = Math.min(100, marsStats.happiness + 15);
                    createPoopSpot();
                    showMessage("MARS feels much better! 💩", Math.max(500, 2000 / timeMultiplier));
                    break;
                    
                case 'pee':
                    marsStats.bladder = Math.max(0, marsStats.bladder - 50);
                    marsStats.happiness = Math.min(100, marsStats.happiness + 10);
                    showMessage("MARS relieved himself! 💛", Math.max(500, 2000 / timeMultiplier));
                    break;
                    
                case 'eat':
                    marsStats.hunger = Math.max(0, marsStats.hunger - 25);
                    marsStats.happiness = Math.min(100, marsStats.happiness + 5);
                    showMessage("MARS munched on some grass! 🍃", Math.max(500, 2000 / timeMultiplier));
                    break;
                    
                case 'explore':
                    marsStats.happiness = Math.min(100, marsStats.happiness + 8);
                    showMessage("MARS enjoyed exploring! 🚶", Math.max(500, 2000 / timeMultiplier));
                    break;
                    
                case 'rest':
                    marsStats.happiness = Math.min(100, marsStats.happiness + 5);
                    break;

                case 'sleep':
                    // During sleep, trigger dream if eligible; then restore and advance day/time
                    const dreamIndex = getNextEligibleDreamIndex();
                    const finishSleep = () => {
                        marsStats.energy = 100;
                        // Advance to next morning 07:00 and increment currentDay
                        const currentHour2 = ((gameTime % 24) + 24) % 24;
                        if (currentHour2 < 7) {
                            gameTime = 7;
                        } else {
                            const hoursToMorning = 24 - currentHour2 + 7;
                            gameTime = (gameTime + hoursToMorning) % 24;
                        }
                        storyManager.currentDay += 1;
                        sleepStartHour = null;
                        showMessage("A new day dawns. MARS feels rested! ☀️", Math.max(500, 2500 / timeMultiplier));
                    };
                    // Only show dream once per night, at night, and only for the first 4 nights
                    const canDreamTonight = isNightHour(sleepStartHour ?? gameTime) && storyManager.lastDreamDay !== storyManager.currentDay && storyManager.completedDreams.length < DREAM_SEQUENCES.length;
                    if (dreamIndex !== -1 && canDreamTonight) {
                        startDreamSequence(dreamIndex, finishSleep);
                    } else {
                        finishSleep();
                    }
                    break;
            }
            
            // Add to history
            marsAI.actionHistory.push({
                action: actionType,
                timestamp: Date.now(),
                statsAfter: {...marsStats}
            });
            
            // Keep history limited
            if (marsAI.actionHistory.length > 10) {
                marsAI.actionHistory.shift();
            }
        }
        
        function createPoopSpot() {
            // Create or grow a poop pile: bigger brown pile with adjacent lumps
            const basePos = new THREE.Vector3(mars.position.x, 0.1, mars.position.z);
            const material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const makeLump = (pos, size=0.35) => {
                const geom = new THREE.SphereGeometry(size, 10, 10);
                const mesh = new THREE.Mesh(geom, material.clone());
                mesh.position.copy(pos);
                mesh.userData = { type: 'poop', created: Date.now(), isPoopLump: true };
                scene.add(mesh);
                poopSpots.push(mesh);
                return mesh;
            };

            if (lastPoopPile.center) {
                // Place adjacent to existing pile center within small radius, and scale some existing lumps
                const offsetAng = Math.random() * Math.PI * 2;
                const offsetRad = 0.25 + Math.random() * 0.25;
                const pos = lastPoopPile.center.clone();
                pos.x += Math.cos(offsetAng) * offsetRad;
                pos.z += Math.sin(offsetAng) * offsetRad;
                const lump = makeLump(pos, 0.3 + Math.random()*0.15);
                lastPoopPile.meshes.push(lump);
                // Randomly scale up one existing lump to grow pile
                if (lastPoopPile.meshes.length > 0) {
                    const idx = Math.floor(Math.random() * lastPoopPile.meshes.length);
                    const m = lastPoopPile.meshes[idx];
                    m.scale.multiplyScalar(1.1);
                }
            } else {
                // Start a new pile at current position with a larger base
                const base = makeLump(basePos, 0.5);
                lastPoopPile.center = basePos.clone();
                lastPoopPile.meshes = [base];
            }
        }
        
        function updateActionQueueUI() {
            const actionList = document.getElementById('actionList');
            actionList.innerHTML = '';
            
            // Show current action
            const currentActionData = ACTIONS[marsAI.currentAction];
            const currentDiv = document.createElement('div');
            currentDiv.className = `action-item ${marsAI.isExecutingUrgentAction ? 'action-urgent' : 'action-current'}`;
            currentDiv.innerHTML = `
                <span class="action-icon">${currentActionData?.icon || '🤔'}</span>
                <span>${currentActionData?.name || 'Thinking...'}</span>
            `;
            actionList.appendChild(currentDiv);
            
            // Show next few actions in queue
            for (let i = 1; i <= 3; i++) {
                const nextIndex = (marsAI.queueIndex + i) % marsAI.actionQueue.length;
                const nextAction = marsAI.actionQueue[nextIndex];
                const nextActionData = ACTIONS[nextAction];
                
                const nextDiv = document.createElement('div');
                nextDiv.className = 'action-item action-queued';
                nextDiv.innerHTML = `
                    <span class="action-icon">${nextActionData?.icon || '❓'}</span>
                    <span>${nextActionData?.name || nextAction}</span>
                `;
                actionList.appendChild(nextDiv);
            }
        }
        
        function updateAIStatus(status) {
            document.getElementById('aiStatus').textContent = status;
        }
        
        function updateStats(deltaTime) {
            const drainRate = 0.5 * timeMultiplier * deltaTime;
            
            marsStats.hunger = Math.min(100, marsStats.hunger + drainRate * 0.8);
            marsStats.thirst = Math.min(100, marsStats.thirst + drainRate * 1.2);
            marsStats.bladder = Math.min(100, marsStats.bladder + drainRate * 0.6);
            marsStats.bowel = Math.min(100, marsStats.bowel + drainRate * 0.4);
            // Energy drains over time, slower when idle
            marsStats.energy = Math.max(0, marsStats.energy - drainRate * 0.5);
            
            // Age progression
            marsStats.age += deltaTime * timeMultiplier / 86400; // Convert to days

            // Time of day progression
            const hoursPerSecondAt1x = 24 / DAY_LENGTH_SECONDS_1X; // hours progressed per real second
            const deltaHours = hoursPerSecondAt1x * deltaTime * timeMultiplier;
            gameTime = (gameTime + deltaHours) % 24;
            
            // Happiness affected by other stats (progressive drain)
            // Progressive penalties kick in earlier and scale up as the stat rises
            let happinessMod = 0;
            // Hunger: start penalizing above 40%
            if (marsStats.hunger > 40) {
                const k = (marsStats.hunger - 40) / 60; // 0..1 from 40->100
                happinessMod -= 0.6 * Math.min(1, Math.max(0, k));
            }
            // Bladder: start penalizing above 30%
            if (marsStats.bladder > 30) {
                const k = (marsStats.bladder - 30) / 70; // 0..1 from 30->100
                happinessMod -= 0.8 * Math.min(1, Math.max(0, k));
            }
            // Bowel: start penalizing above 30%
            if (marsStats.bowel > 30) {
                const k = (marsStats.bowel - 30) / 70; // 0..1 from 30->100
                happinessMod -= 0.8 * Math.min(1, Math.max(0, k));
            }
            // Keep thirst penalty at high levels as before
            if (marsStats.thirst > 70) happinessMod -= 0.7;

            marsStats.happiness = Math.max(0, Math.min(100, marsStats.happiness + happinessMod * deltaTime));
            
            // Growth stages
            updateGrowth();
            
            // UI update
            updateUI();
        }
        
        function updateGrowth() {
            let newSize = 'baby';
            let scale = 1;
            
            if (marsStats.age > 365) {
                newSize = 'juvenile';
                scale = 1.3;
            }
            if (marsStats.age > 730) {
                newSize = 'adolescent';
                scale = 1.6;
            }
            if (marsStats.age > 1095) {
                newSize = 'young adult';
                scale = 2.0;
            }
            if (marsStats.age > 1460) {
                newSize = 'adult';
                scale = 2.5;
            }
            
            if (newSize !== marsStats.size) {
                marsStats.size = newSize;
                mars.scale.set(scale, scale, scale);
                showMessage(`MARS is growing! Now a ${newSize}! 🎉`);
            }
        }
        
        function updateUI() {
            document.getElementById('hungerBar').style.width = marsStats.hunger + '%';
            document.getElementById('thirstBar').style.width = marsStats.thirst + '%';
            document.getElementById('bladderBar').style.width = marsStats.bladder + '%';
            document.getElementById('bowelBar').style.width = marsStats.bowel + '%';
            document.getElementById('happinessBar').style.width = marsStats.happiness + '%';
            const energyEl = document.getElementById('energyBar');
            if (energyEl) energyEl.style.width = marsStats.energy + '%';
            
            document.getElementById('ageDisplay').textContent = Math.floor(marsStats.age) + ' days';
            document.getElementById('sizeDisplay').textContent = marsStats.size;
            // Day/Time display
            const hour = Math.floor(((gameTime % 24) + 24) % 24);
            const minutes = Math.floor(((gameTime - Math.floor(gameTime)) * 60));
            const pad = (n) => n.toString().padStart(2, '0');
            document.getElementById('dayTimeDisplay').textContent = `Day ${storyManager.currentDay}, ${pad(hour)}:${pad(minutes)}`;
            document.getElementById('scoreDisplay').textContent = marsStats.score;
            // Sleep button state
            const sleepBtn = document.getElementById('sleepBtn');
            const canSleep = marsStats.energy <= 0 || isNightHour(gameTime) || marsStats.energy < 20;
            sleepBtn.disabled = inDream || !canSleep;
        }
        
        function toggleTimeSpeed() {
            const speeds = [1, 5, 10];
            const currentIndex = speeds.indexOf(timeMultiplier);
            timeMultiplier = speeds[(currentIndex + 1) % speeds.length];
            document.getElementById('timeSpeed').textContent = `Time: ${timeMultiplier}x`;
            showMessage(`Time speed set to ${timeMultiplier}x`);
        }
        
        function showMessage(text, duration = 3000) {
            // Create floating message
            const message = document.createElement('div');
            message.textContent = text;
            message.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 10px 20px;
                border-radius: 10px;
                z-index: 150;
                pointer-events: none;
                font-size: 18px;
                border: 2px solid #FFD700;
            `;
            
            document.body.appendChild(message);
            
            setTimeout(() => {
                if (message.parentNode) {
                    message.parentNode.removeChild(message);
                }
            }, duration);
        }
        
        // Opening sequence functions
        function startOpeningSequence() {
            // Show brief story, then immediately start opening curtains
            document.getElementById('story').style.display = 'block';
            document.getElementById('storyText').textContent = "Welcome to MARS's world! 🦛";
            
            // Auto-continue after 2 seconds
            setTimeout(() => {
                document.getElementById('story').style.display = 'none';
                document.getElementById('curtains').classList.add('curtains-open');
                
                // Start game after curtains finish opening
                setTimeout(() => {
                    document.getElementById('curtains').style.display = 'none';
                    isGameStarted = true;
                    startGameLoop();
                }, 3000);
            }, 2000);
        }
        
        function continueStory() {
            // This function is now unused as we auto-start
            startOpeningSequence();
        }
        
        function startGameLoop() {
            showMessage("MARS is now autonomous! Watch him make his own decisions! 🧠", 5000);
            
            // Initialize AI system
            marsAI.actionStartTime = Date.now();
            marsAI.lastThoughtTime = Date.now();
            updateActionQueueUI();
            updateAIStatus('Starting autonomous mode...');
            
            gameLoop();
        }
        
        function gameLoop() {
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            if (isGameStarted && !inDream) {
                updateMarsAI(deltaTime);
                updateMars(deltaTime);
                updateBeetles(deltaTime);
                updateFrogs(deltaTime);
                updateStats(deltaTime);
                updateEnvironment();
                updateBackflip(deltaTime);   // backflip per-frame update
                animateSplash();             // per-frame splash animation
                const splashBtn = document.getElementById('splashBtn');
                if (splashBtn) splashBtn.disabled = !isMarsInWater();
            }
            
            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }
        
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 25;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function saveGame() {
            const saveData = {
                stats: marsStats,
                position: { x: mars.position.x, y: mars.position.y, z: mars.position.z },
                timeMultiplier: timeMultiplier,
                gameTime: gameTime,
                storyManager: storyManager,
                storyLog: storyLog,
                aiState: {
                    currentAction: marsAI.currentAction,
                    queueIndex: marsAI.queueIndex,
                    actionHistory: marsAI.actionHistory
                },
                timestamp: Date.now()
            };
            
            localStorage.setItem('marsHippoGame', JSON.stringify(saveData));
            showMessage("Game saved! 💾");
        }
        
        function loadGame() {
            const saveData = localStorage.getItem('marsHippoGame');
            if (!saveData) {
                showMessage("No save file found!");
                return;
            }
            
            try {
                const data = JSON.parse(saveData);
                marsStats = data.stats;
                mars.position.set(data.position.x, data.position.y, data.position.z);
                timeMultiplier = data.timeMultiplier;
                document.getElementById('timeSpeed').textContent = `Time: ${timeMultiplier}x`;
                if (typeof data.gameTime === 'number') gameTime = data.gameTime;
                if (data.storyManager) storyManager = data.storyManager;
                if (Array.isArray(data.storyLog)) {
                    storyLog = data.storyLog;
                    renderStoryLog();
                }
                
                // Restore AI state
                if (data.aiState) {
                    marsAI.currentAction = data.aiState.currentAction || 'idle';
                    marsAI.queueIndex = data.aiState.queueIndex || 0;
                    marsAI.actionHistory = data.aiState.actionHistory || [];
                    marsAI.actionStartTime = Date.now(); // Reset action timer
                }
                
                updateGrowth();
                updateActionQueueUI();
                showMessage("Game loaded! 📁");
            } catch (error) {
                showMessage("Save file corrupted!");
            }
        }

        // Phase 2 helpers: dream triggering and display
        function getNextEligibleDreamIndex() {
            // Limit to one new dream per night and only 4 total. Use next index in sequence.
            const nextIndex = storyManager.completedDreams.length;
            if (nextIndex >= DREAM_SEQUENCES.length) return -1;
            // Optionally keep age gates; if age not reached, skip dream
            if (marsStats.age < DREAM_SEQUENCES[nextIndex].ageTriggerDays) return -1;
            return nextIndex;
        }

        function startDreamSequence(index, onComplete) {
            inDream = true;
            const dream = DREAM_SEQUENCES[index];
            const storyEl = document.getElementById('story');
            const storyText = document.getElementById('storyText');
            storyEl.style.display = 'block';
            storyEl.style.zIndex = 400;
            let idx = 0;

            const nextBubble = () => {
                if (idx >= dream.dialogue.length) {
                    // Finish dream
                    storyEl.style.display = 'none';
                    inDream = false;
                    storyManager.completedDreams.push(index);
                    storyManager.lastDreamDay = storyManager.currentDay;
                    addToStoryLog(`Dream ${index + 1} completed on Day ${storyManager.currentDay}.`);

                    // Check for game completion
                    if (storyManager.completedDreams.length >= DREAM_SEQUENCES.length) {
                        showGameCompletionMessage();
                    }

                    if (typeof onComplete === 'function') onComplete();
                    return;
                }
                const line = dream.dialogue[idx++];
                storyText.textContent = line;
                addToStoryLog(`Dream ${index + 1}: ${line}`);
                setTimeout(nextBubble, Math.max(1200, 2200 / timeMultiplier));
            };
            nextBubble();
        }

        function showMessage(message) {
            const logContainer = document.getElementById('messageLog');
            const msgEl = document.createElement('div');
            msgEl.className = 'log-message';
            msgEl.textContent = message;
            
            // Prepend to have newest on top, then scroll to top
            logContainer.insertBefore(msgEl, logContainer.firstChild);
            logContainer.scrollTop = 0;

            // Optional: Limit number of messages
            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        function showGameCompletionMessage() {
            const storyEl = document.getElementById('story');
            storyEl.innerHTML = `
                <h2>🌟 Congratulations! 🌟</h2>
                <p>MARS has grown into a healthy, happy hippo thanks to your care!</p>
                <p>You've experienced his full journey from a stubborn baby to a symbol of hope for his species.</p>
                <p>The game will now continue in sandbox mode. Keep exploring and caring for MARS!</p>
                <button onclick="document.getElementById('story').style.display='none'" style="margin-top:15px;">Continue Playing</button>
            `;
            storyEl.style.display = 'block';
        }

        // The toggleStoryLog function is now replaced by toggleJournal.
        // The story log is now a tab within the journal.
        
        // Start the game
        init();
    </script>
</body>
</html>